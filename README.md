# ASP.NET Core Middleware Framework

В работе реализован простой Web API на ASP.NET Core, основной целью которого
является демонстрация middleware-конвейера и разделения инфраструктурного кода
и логики предметной области.

Проект не использует базу данных — все данные хранятся в памяти процесса.

---

## Требования

- .NET SDK 8.0
- ОС: Windows / Linux / macOS

Проверка версии .NET:
dotnet --version

---

## Запуск проекта

1. Клонировать репозиторий:

git clone https://github.com/<username>/aspnet-core-middleware-framework.git  
cd aspnet-core-middleware-framework

2. Запустить приложение:

dotnet restore  
dotnet run

3. Открыть Swagger UI в браузере:

https://localhost:XXXX/swagger

Порт указывается в консоли после запуска приложения.

---

## Общая идея и архитектура

Приложение построено вокруг стандартного HTTP-конвейера ASP.NET Core.
Вся обработка запроса проходит через последовательность middleware,
каждый из которых отвечает за одну конкретную задачу.

Архитектура условно разделена на два уровня:

---

### 1. Инфраструктурный уровень (middleware)

В middleware вынесены все общие задачи, которые не зависят от предметной области:

- **RequestIdMiddleware**  
  Генерирует уникальный идентификатор запроса и сохраняет его в контексте.
  Этот идентификатор возвращается клиенту и используется в логах.

- **ErrorHandlingMiddleware**  
  Перехватывает необработанные исключения и возвращает единый JSON-ответ
  с кодом ошибки, сообщением и requestId.

- **LoggingMiddleware**  
  Логирует HTTP-метод, путь запроса, статус ответа и время обработки.

Такой подход позволяет не дублировать код логирования и обработки ошибок
в контроллерах.

---

### 2. Логика приложения

В контроллере ItemsController реализована предметная логика работы с элементами:

- получение списка элементов
- получение элемента по идентификатору
- создание нового элемента
- проверка корректности входных данных

Контроллеры не содержат инфраструктурного кода и работают только с бизнес-логикой.

---

## Маршруты API

В проекте реализованы следующие точки доступа:

- GET /api/items — получить список элементов
- GET /api/items/{id} — получить элемент по id
- POST /api/items — создать новый элемент

Для маршрутизации используется атрибутный подход, что делает код
понятным и легко читаемым.

---

## Формат ошибок

Все ошибки в приложении возвращаются в одном формате:

{
  "requestId": "uuid",
  "error": {
    "code": 400,
    "message": "Описание ошибки"
  }
}

Данный формат используется для ошибок 400, 404 и 500.

---

## Примеры проверок

### Получение списка элементов

GET /api/items  
Ожидается: 200 OK и массив элементов.

---

### Получение элемента по id

GET /api/items/1  

Если элемент существует — 200 OK.  
Если нет — 404 Not Found в едином формате ошибки.

---

### Создание элемента

POST /api/items  

Body:
{
  "name": "Test item",
  "price": 100
}

Ожидается: 201 Created.

---

### Ошибка валидации

POST /api/items  

Body:
{
  "name": "",
  "price": -10
}

Ожидается: 400 Bad Request с описанием ошибки.

---

### Проверка обработки исключений

GET /api/items/crash  

Эндпоинт специально выбрасывает исключение.
Ожидается: 500 Internal Server Error с requestId.

---

## Экспериментальная часть

В рамках работы наблюдалось время обработки HTTP-запросов,
которое измеряется в LoggingMiddleware.

### Независимая переменная
Тип обрабатываемого запроса:
- корректный запрос
- запрос с ошибкой валидации
- запрос с исключением

### Зависимая переменная
Время обработки запроса (в миллисекундах).

### Наблюдения
Ошибочные запросы обрабатываются быстрее, чем успешные,
так как выполнение завершается раньше.
Наличие requestId упрощает поиск соответствующих логов
при возникновении ошибок.

---

## Ограничения и риски

- Данные хранятся в памяти и не сохраняются при перезапуске приложения.
- In-memory хранилище не рассчитано на высокую нагрузку.
- Приложение не предназначено для production-использования.

---

## Вывод

Использование middleware позволяет построить понятный и аккуратный каркас
веб-приложения, в котором инфраструктурные задачи вынесены отдельно
и не мешают реализации логики предметной области.
